This is the self-evaluation text file for the kernel project done by Lanea Rohan. 

The categories are listed as they appear in the rubric. Next to each category 
is a score that I have given myself, as well as an explanation or justification for
the score given. Additional comments may be amended below each section if there 
is more information that I think is key to understanding a particular rubric item. 

PLEASE NOTE: there are two branches on my github associated with this project. As per 
    your comment to me in office hours, I am going to submit them unmerged. 
    REORGANIZE: holds pretty much all documentation. 
    MAIN: holds the shell and additional modules. 

1. Input/Output
    Score: 3/3
    Justification: I have a large test set in the testing.c file. Unfortunately, some of 
        the function names have changed as they migrated into the stdlib, however the core 
        tests have remained the same. Comments alongside the different calls tell you what 
        you should expect to see if you run them. 

2. Exceptions: 
    Score: 3/3
    Justification: I can trigger exceptions using the __asm__ command given in the 
        instructions for exceptions. I also have been triggering them as I have been working
        through the rest of the kernel implementation. 

3. Virtual Memory: 
    Score: 3/3
    Justification: I can run the init program in usermode, meaning that I can 
        use vm_map and vm_protect to allocate memory to hold a new process. 

4. System Calls: 
    Score: 1/3
    Justification: I have both the read and write system calls working, because I 
        because I can use them in the init program. I have no clue if mmap (via malloc)
        works because I haven't tried testing it at all. 

5. Loader: 
    Score: 3/3
    Justification: I can run the init program in userrmode, meaning that I can load 
        and execute init. 

6. Standard Library: 
    Score: 3/3 (unless we were required to implement printf, then 2/3)
    Justification: Modules link to a standard library and can use functions given 
        there. This can be seen by the ability to call read(), write(), exec(), exit()
        from modules. I don't think I have any functions that are floating around the 
        kernel which are completely usermode friendly. However, if we were required to 
        implement printf (and not use it as a suggestion to functions we could choose
        to implement) then I'll give myself a 2/3.

7. User Mode: 
    Score: 3/3
    Justification: I can reach usermode in the init program. If there is an access to a 
        page marked as non-user accessible, then there is a page fault. 


For the following two (processees and shell): I'm not entirely sure what is happening, so these scores are extremely
tentative. Both are broken, but I'm not sure why either of them is broken. If it is only exec that has 
broken the shell (but if exec was fixed then the shell would work, which is my suspicion), then I think the shell 
is fine enough to be worth 3/3. However, it currently cannot do that, which is why it has been given a 1/3. 

8. Processess: 
    Score: 2/3
    Justification: I can call exec using the name of a module from boot. However, it only
        runs the init program, even though I have not hardcoded it to do so (at least I 
        don't think I have). So, exec works - it unmaps the lower half, and loads a new 
        executable. However, the executable is always init, and it doesn't like getting called 
        from init to do something. If I were to guess where the problem is, I'd say its coming from when I ask to 
        execute a new program, there is an interrupt when setting up the new gdt and thus it just freezes. 
        However, it does not crash, although it is somewhat lacking functionality, putting it into the 2/3 
        category. 

9. Shell: 
    Score: 1/3
    Justificaton: It kind of behaves like a shell. For some reason it duplicates whatever you 
        type into the terminal, however other than the fact that exec() doesn't do what it's supposed to,
        it maybe works okay. If you type in a valid command, it will just stop (thanks exec()). If you type 
        in an invalid command, it will tell you it is invalid and prompt you for another command. 

10. Code Quality: 
    Score: 3/3
    Justification: I think between function documentation and inter-function comments, code is clear and 
        divided logically. Relatively short is, of course, relative. It would have been better
        if I had been able to keep up with my README, but alas. 

Total Score: 25/30
